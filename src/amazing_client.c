/* Startup script for our amazing project
 * Parses command line arguments as per the specifications
 *	-n nAvatars: (int) the number of Avatars in the maze
 *	-d Difficulty: (int) the difficulty level, on the scale 0 (easy) to 9 (excruciatingly difficult)
 *	-h Hostname: (char *) the hostname of the server. Our server will be running on flume.cs.dartmouth.edu
 * 
 * Constructs and sends the AM_INIT message to the server
 * Recovers the MazePort from the server reply, AM_INIT_OK
 * Creates a new log file with the name Amazing_$USER_N_D.log
 *	-where $USER is the current userid
 *	-N is the value of nAvatars
 *	-D is the value of Difficulty.
 *
 * Initializes N copies of the avatar client with parameters:
 *	-AvatarId (an integer generated by AMStartup, starting at 0 and incremented by one for each subsequent Avatar started)
 *	-nAvatars (total number of Avatars)
 *	-Difficulty (difficulty of the maze)
 *	-Host name or IP address of the server
 *	-MazePort (as returned in the AM_INIT_OK message)
 *	-Filename of the log the Avatar should open for writing in append mode
 *
 * 
 * Status:
 *		0 - No errors
 *		1 - Incorrect formatting of args
 *		2 - Invalid arguments
 *		3 - Maze Initialization Failed
 *		4 - Stream (file or socket) error
 *		5 - Thread error creation
 *
 * CS50 W18 Group 5
 */
#include "mazeGraph.h"
#include "simpleAvatar.h"
#include "message.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>        	
#include <ctype.h>
#include "amazing.h"
#include <unistd.h>    			
#include <sys/types.h>
#include <pwd.h>
#include <time.h>
#include <stdbool.h>
#include <pthread.h>

#include <netdb.h>          // socket-related structures
#include <arpa/inet.h>      // socket-related calls
#include <sys/select.h>     // select-related stuff 
#include <errno.h>          // error handling
#include <signal.h>
#ifdef DISPLAY
#include "graphics.h"
#endif 

// Function prototypes
void *initAvatar(void *ptr);

// Static check messages
static bool checkMessages(uint32_t messageType, FILE *fp);

// Mutex 
pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;

typedef struct initStruct {
 	int avatarId;
 	int nAvatars;
 	int difficulty;
 	char *hostname;
 	int mazePort;
 	char *logFile;
	mazeGraph* mGraph; 
	int *totalTurns;
} init_t;

/*
 * Initializes the avatar, given an init_t struct
 * Used within the context of multi-threading in main
 * 
 * Runs concurrently with other avatars
 */
void *initAvatar(void *ptr)
{
	//Parse the void * into usable form
	init_t *a = (init_t *)ptr;
	int id = a->avatarId;

	struct sockaddr_in mazeAvatar;

	// Create and connect socket for each avatar
	int mazeSock = socket_setup(a->hostname, &mazeAvatar, a->mazePort);

	if (connect(mazeSock, (struct sockaddr *) &mazeAvatar, sizeof(mazeAvatar)) < 0) {
		perror("connecting stream socket");
		exit(4);
	}

	XYPos pos;				// Current pos
	XYPos prevPos;			// Prev pos
	bool solved = false;	// Solved bool

	// Send avatar ready message to server
	avatarReadyMsg(mazeSock, id);

	// Recieve the ready message returned from server 
	AM_Message receiveMessage;
	receiveMsg(&receiveMessage, mazeSock);

	// Parse ready message
	uint32_t messageType = ntohl(receiveMessage.type);

	// Get Avatar's initial position
	if (messageType == AM_AVATAR_TURN) {  
  		pos.x  = ntohl(receiveMessage.avatar_turn.Pos[a->avatarId].x);
	 	pos.y = ntohl(receiveMessage.avatar_turn.Pos[a->avatarId].y);
	}

	// Open the log file to append moves
	FILE *fp = fopen(a->logFile, "a");
	if (fp == NULL) {
		fprintf(stderr, "Cannot open log file");
		exit(4);
	}

	// Write Initializations to file 
	fprintf(fp, "Initialized Avatar: %d at (%d,%d)\n", id, pos.x, pos.y);
	fflush(fp);

	sleep(.001);
	// Initialize the avatars at the respective coodinates
	init_avatar(a->mGraph, pos.x, pos.y, id);

	int move;
	int prevdirection = 1;
	bool moveSuccess;

	// Calculate maximum number of moves
	int maxMoves = AM_MAX_MOVES * (a->difficulty + 1) * (a->nAvatars + 1); 
	char moveStr[20];
	sprintf(moveStr, "%d", maxMoves);
	int moveLen = strlen(moveStr);

	// Runs until the maze is solved
	while(!solved) {

		// Check if it is the avatar's turn
		if (id == ntohl(receiveMessage.avatar_turn.TurnId)) {

			// lock when avatar's turn
			pthread_mutex_lock(&mutex);

			// Calculate a move using our graph data structure
			move = decsionMaker(a->mGraph, pos, prevdirection, id, 1);
			
			// Set previous position
			prevPos.x = pos.x;
			prevPos.y = pos.y;

			// Message structs
			AM_Message avatarTurnMessage;
			AM_Message receiveMessage;

			// Zero the messages
   			memset(&avatarTurnMessage, 0, sizeof(AM_Message)); 
   			memset(&receiveMessage, 0, sizeof(AM_Message));  

   			// Send and receive message
			if(!avatarMoveMsg(mazeSock, id, move)) {
				fprintf(stderr, "ERROR: recv: %s (%d)\n", strerror(errno), errno);
			}
			if(!receiveMsg(&receiveMessage, mazeSock)) {
			    fprintf(stderr, "ERROR: recv: %s (%d)\n", strerror(errno), errno);
			}

			// Parse turn message
			uint32_t messageType = ntohl(receiveMessage.type);

			if (messageType == AM_AVATAR_TURN) {  
	      		pos.x  = ntohl(receiveMessage.avatar_turn.Pos[id].x);
			 	pos.y = ntohl(receiveMessage.avatar_turn.Pos[id].y);
			}

			// Update the graph
			moveSuccess = updateAvatarGraph(a->mGraph, pos, prevPos, id, move);


			// If display is turned on, display via graphics. Otherwise, display on-screen
			#ifdef DISPLAY
			set_maze(maze_get_walls(a->mGraph), maze_get_width(a->mGraph), maze_get_height(a->mGraph));
			#else
			maze_print(a->mGraph);
			#endif


			// Update the previous direction moved
			if (moveSuccess) {
				// Write avatar's move to file
				fprintf(fp, "Turn %*d/%d: Avatar %d moved in direction %d from (%d,%d) to (%d,%d) \n",
				 moveLen, *(a->totalTurns), maxMoves, id, move, prevPos.x, prevPos.y, pos.x, pos.y);
				fflush(fp);
				prevdirection = move;
			} else {
				// Move denied by wall
				if (move == M_NULL_MOVE) {
					fprintf(fp, "Turn %*d/%d: Avatar %d at beacon (%d,%d) \n", moveLen,
					 *(a->totalTurns), maxMoves, id, pos.x, pos.y);
				} else {
					fprintf(fp, "Turn %*d/%d: Avatar %d moved in direction %d from (%d,%d) to (%d,%d) | Denied by Wall \n", 
					moveLen, *(a->totalTurns), maxMoves, id, move, prevPos.x, 
					 prevPos.y, pos.x, pos.y);
				}	
				fflush(fp);
			}

			// Check if valid message 
			solved = checkMessages(messageType, fp);

			// Clean and exit if solved
			if(solved) {
				fprintf(fp, "Maze Solved with %d turns!\n", *(a->totalTurns));
				fflush(fp);
				fclose(fp);
				return 0;
			}

			// Increment total turn count
			*(a->totalTurns) = *(a->totalTurns) + 1;

			fflush(stdout);
			// Unlock 
			pthread_mutex_unlock(&mutex);
		}

		// Receive the message
		if(!receiveMsg(&receiveMessage, mazeSock)) {
		    fprintf(stderr, "ERROR: recv: %s (%d)\n", strerror(errno), errno);
		}
		// Parse turn message
		uint32_t messageType = ntohl(receiveMessage.type);

		if (messageType == AM_AVATAR_TURN) {  
      		pos.x  = ntohl(receiveMessage.avatar_turn.Pos[id].x);
		 	pos.y = ntohl(receiveMessage.avatar_turn.Pos[id].y);
		}
		
		solved = checkMessages(messageType, fp);
		if(solved){
			fclose(fp);
			return 0; 
		}
	}
	fclose(fp);			// close the file pointer
	close(mazeSock);	// close the maze socket
    return 0;
}

// Check if maze is solved or error
static bool checkMessages(uint32_t messageType, FILE *fp) {

	if (messageType == AM_MAZE_SOLVED) {
		printf("Maze solved!\n\n");
		return true;
	}  else if (IS_AM_ERROR(messageType)){
		if (messageType == AM_TOO_MANY_MOVES) {
			printf("ERROR: Too Many Moves!\n\n");
			fprintf(fp, "ERROR: Too Many Moves!");	
			exit(6);
		} else if (messageType == AM_AVATAR_OUT_OF_TURN) {
			printf("ERROR: Avatar out of Turn!\n\n");
			fprintf(fp, "ERROR: Avatar out of Turn!");
		} else if (messageType == AM_SERVER_DISK_QUOTA) {
			printf("ERROR: AM Server Out of Server Disk Quota!\n\n");
			exit(6);
		} else if (messageType == AM_SERVER_TIMEOUT ) {
			printf("ERROR: AM Server Timeout!!\n\n");
			fprintf(fp, "ERROR: AM Server Timeout");
			exit(6);
		} else if(messageType == AM_SERVER_OUT_OF_MEM) {
			printf("ERROR: AM Server out of MEM!\n\n");
			fprintf(fp, "ERROR: AM Server out of MEM");
		} else if(messageType == AM_UNKNOWN_MSG_TYPE ) {
			printf("ERROR: Unknown Message Type!\n\n");
			fprintf(fp, "ERROR: AM Unknown Message Type");
		} else if (messageType == AM_UNEXPECTED_MSG_TYPE ) {
			printf("ERROR: Unexpected Message Type!\n\n");
			fprintf(fp, "ERROR: Unexpected Message Type");
		}
    }
    return false; 
}


		


